import { ConnectRequestOptions } from './packets';
import { MqttParser } from './mqtt.parser';
import { Transport, TlsTransportProxyOptions } from './transport';
import { XOR } from 'ts-xor';
import { MqttMessage } from './mqtt.message';
export declare type MqttClientConstructorOptions = XOR<{
    transport: Transport<unknown>;
}, {
    url: string;
    enableTrace?: boolean;
    proxyOptions?: TlsTransportProxyOptions;
}> & {
    parser?: MqttParser;
    autoReconnect?: boolean;
};
export interface MqttSubscription {
    topic: string;
    qosLevel?: number;
}
export declare type RegisterClientOptions = ConnectRequestOptions;
export declare type ExecuteNextTick = (action: () => void) => void;
export declare type ExecutePeriodically = (timeInMs: number, action: () => void) => object;
export declare type ExecuteDelayed = (timeInMs: number, action: () => void) => object;
export declare type StopExecuting = (ref: any) => void;
export declare type AsyncLike<TIn, TOut> = (data: TIn) => TOut | PromiseLike<TOut>;
export interface ListenerInfo<TIn, TOut> {
    eventName: string;
    validator: (data: TIn) => boolean | PromiseLike<boolean>;
    transformer?: (data: TIn) => TOut | PromiseLike<TOut>;
    onData: (data: TOut) => void | PromiseLike<void>;
}
export interface ListenOptions<TOut> {
    topic: string;
    validator?: null | ((data: MqttMessage) => boolean);
    transformer?: (data: IncomingListenMessage<any>) => TOut;
}
export interface ListenSubscribeOptions<TOut> extends ListenOptions<TOut> {
    subscriptionInfo?: Partial<MqttSubscription>;
}
export interface IncomingListenMessage<T> extends MqttMessage {
    params?: T;
}
export declare type Resolvable<T extends object> = (() => Promise<T>) | (() => T) | T;
